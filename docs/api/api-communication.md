# API äº¤äº’é€šè®¯æ¶æ„æ–‡æ¡£

## æ¦‚è¿°

æœ¬æ–‡æ¡£è¯¦ç»†ä»‹ç»äº†å–µå’•è®°äº‹æœ¬çš„APIäº¤äº’é€šè®¯æ¶æ„ï¼ŒåŒ…æ‹¬å‰åç«¯é€šè®¯æœºåˆ¶ã€æ•°æ®æµå‘ã€çŠ¶æ€ç®¡ç†ã€é”™è¯¯å¤„ç†ç­‰æ ¸å¿ƒæ¶æ„è®¾è®¡ã€‚

---

## ğŸ—ï¸ æ•´ä½“æ¶æ„

### æ¶æ„å›¾

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    å‰ç«¯ React åº”ç”¨                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”‚
â”‚  â”‚   UI ç»„ä»¶   â”‚  â”‚  è‡ªå®šä¹‰Hook â”‚  â”‚  å·¥å…·å‡½æ•°   â”‚         â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â”‚
â”‚         â”‚               â”‚               â”‚                  â”‚
â”‚         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                  â”‚
â”‚                         â”‚                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”‚              Redux çŠ¶æ€ç®¡ç†å±‚                            â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”‚
â”‚  â”‚  â”‚ themeSlice  â”‚ â”‚ editorSlice â”‚ â”‚  fileSlice  â”‚       â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                         â”‚                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”‚              Tauri API é€šè®¯å±‚                           â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”‚
â”‚  â”‚  â”‚  æ–‡ä»¶æ“ä½œ   â”‚ â”‚  ç³»ç»Ÿé›†æˆ   â”‚ â”‚  æ–‡ä»¶ç›‘æ§   â”‚       â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                         â”‚
                    IPC é€šè®¯åè®®
                         â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   åç«¯ Tauri åº”ç”¨                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”‚
â”‚  â”‚  æ–‡ä»¶ç³»ç»Ÿ   â”‚  â”‚  ç³»ç»Ÿè°ƒç”¨   â”‚  â”‚  è¿›ç¨‹ç®¡ç†   â”‚         â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â”‚
â”‚         â”‚               â”‚               â”‚                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”‚                Rust æ ¸å¿ƒé€»è¾‘                            â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”‚
â”‚  â”‚  â”‚  ç¼–ç æ£€æµ‹   â”‚ â”‚  æ–‡ä»¶ç›‘æ§   â”‚ â”‚  ç³»ç»ŸåŠŸèƒ½   â”‚       â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                         â”‚
                    æ“ä½œç³»ç»Ÿ API
                         â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     æ“ä½œç³»ç»Ÿ                                â”‚
â”‚    æ–‡ä»¶ç³»ç»Ÿ â”‚ è¿›ç¨‹ç®¡ç† â”‚ ç½‘ç»œ â”‚ ç¡¬ä»¶æŠ½è±¡å±‚                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ”„ é€šè®¯æœºåˆ¶

### 1. å‰åç«¯é€šè®¯åè®®

#### IPC (Inter-Process Communication) é€šè®¯

| é€šè®¯æ–¹å‘    | åè®®ç±»å‹          | æ•°æ®æ ¼å¼ | æè¿°       |
|---------|---------------|------|----------|
| å‰ç«¯ â†’ åç«¯ | Tauri Command | JSON | å‰ç«¯è°ƒç”¨åç«¯åŠŸèƒ½ |
| åç«¯ â†’ å‰ç«¯ | Tauri Event   | JSON | åç«¯ä¸»åŠ¨æ¨é€äº‹ä»¶ |
| åŒå‘      | WebSocket     | JSON | å®æ—¶æ•°æ®åŒæ­¥   |

#### é€šè®¯æµç¨‹

```javascript
// 1. å‰ç«¯å‘èµ·è¯·æ±‚
const request = {
    command: 'read_file_content',
    payload: {
        file_path: '/path/to/file.txt'
    }
};

// 2. Tauri IPC ä¼ è¾“
const response = await invoke('read_file_content', {
    filePath: '/path/to/file.txt'
});

// 3. åç«¯å¤„ç†å¹¶è¿”å›
{
    success: true,
        data
:
    {
        content: "æ–‡ä»¶å†…å®¹",
            encoding
    :
        "utf-8",
            line_ending
    :
        "LF"
    }
,
    error: null
}
```

### 2. æ•°æ®åºåˆ—åŒ–

#### è¯·æ±‚æ•°æ®ç»“æ„

```typescript
interface ApiRequest<T = any> {
    command: string;           // å‘½ä»¤åç§°
    payload: T;               // è¯·æ±‚å‚æ•°
    requestId?: string;       // è¯·æ±‚IDï¼ˆç”¨äºè¿½è¸ªï¼‰
    timestamp?: number;       // æ—¶é—´æˆ³
}
```

#### å“åº”æ•°æ®ç»“æ„

```typescript
interface ApiResponse<T = any> {
    success: boolean;         // æ“ä½œæ˜¯å¦æˆåŠŸ
    data?: T;                // è¿”å›æ•°æ®
    error?: {                // é”™è¯¯ä¿¡æ¯
        code: string;
        message: string;
        details?: any;
    };
    requestId?: string;      // å¯¹åº”çš„è¯·æ±‚ID
    timestamp: number;       // å“åº”æ—¶é—´æˆ³
}
```

---

## ğŸ“¡ API é€šè®¯å±‚

### 1. Tauri API å°è£… (tauriApi.js)

#### æ ¸å¿ƒé€šè®¯å‡½æ•°

```javascript
// åŸºç¡€è°ƒç”¨å‡½æ•°
async function invokeCommand(command, payload = {}) {
    try {
        const startTime = performance.now();

        // æ·»åŠ è¯·æ±‚æ—¥å¿—
        console.log(`[API] è°ƒç”¨å‘½ä»¤: ${command}`, payload);

        const result = await invoke(command, payload);

        const endTime = performance.now();
        console.log(`[API] å‘½ä»¤å®Œæˆ: ${command} (${endTime - startTime}ms)`);

        return {
            success: true,
            data: result,
            error: null,
            duration: endTime - startTime
        };

    } catch (error) {
        console.error(`[API] å‘½ä»¤å¤±è´¥: ${command}`, error);

        return {
            success: false,
            data: null,
            error: {
                code: error.code || 'UNKNOWN_ERROR',
                message: error.message || 'æœªçŸ¥é”™è¯¯',
                details: error
            }
        };
    }
}

// å¸¦é‡è¯•æœºåˆ¶çš„è°ƒç”¨
async function invokeWithRetry(command, payload, maxRetries = 3) {
    let lastError;

    for (let attempt = 1; attempt <= maxRetries; attempt++) {
        try {
            const result = await invokeCommand(command, payload);

            if (result.success) {
                return result;
            }

            lastError = result.error;

            // å¦‚æœæ˜¯ç½‘ç»œé”™è¯¯æˆ–ä¸´æ—¶é”™è¯¯ï¼Œè¿›è¡Œé‡è¯•
            if (shouldRetry(result.error) && attempt < maxRetries) {
                const delay = Math.pow(2, attempt) * 1000; // æŒ‡æ•°é€€é¿
                await new Promise(resolve => setTimeout(resolve, delay));
                continue;
            }

            break;

        } catch (error) {
            lastError = error;

            if (attempt < maxRetries) {
                const delay = Math.pow(2, attempt) * 1000;
                await new Promise(resolve => setTimeout(resolve, delay));
            }
        }
    }

    return {
        success: false,
        data: null,
        error: lastError
    };
}

// åˆ¤æ–­æ˜¯å¦åº”è¯¥é‡è¯•
function shouldRetry(error) {
    const retryableCodes = [
        'NETWORK_ERROR',
        'TIMEOUT_ERROR',
        'TEMPORARY_ERROR',
        'FILE_LOCKED'
    ];

    return retryableCodes.includes(error.code);
}
```

#### API åˆ†ç±»å°è£…

```javascript
// æ–‡ä»¶æ“ä½œ API
export const fileApi = {
    // è¯»å–æ–‡ä»¶
    async readFile(filePath) {
        return await invokeCommand('read_file_content', {filePath});
    },

    // å†™å…¥æ–‡ä»¶
    async writeFile(filePath, content, encoding = 'utf-8') {
        return await invokeCommand('write_file_content', {
            filePath,
            content,
            encoding
        });
    },

    // ä¿å­˜æ–‡ä»¶
    async saveFile(filePath, content, encoding = 'utf-8', lineEnding = 'LF') {
        return await invokeCommand('save_file', {
            filePath,
            content,
            encoding,
            lineEnding
        });
    },

    // æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å­˜åœ¨
    async checkExists(filePath) {
        return await invokeCommand('check_file_exists', {filePath});
    },

    // è·å–æ–‡ä»¶ä¿¡æ¯
    async getFileInfo(filePath) {
        return await invokeCommand('get_file_info', {filePath});
    },

    // è·å–ç›®å½•å†…å®¹
    async getDirectoryContents(dirPath) {
        return await invokeCommand('get_directory_contents', {dirPath});
    },

    // é‡å‘½åæ–‡ä»¶
    async renameFile(oldPath, newPath) {
        return await invokeCommand('rename_file', {oldPath, newPath});
    }
};

// ç³»ç»Ÿé›†æˆ API
export const systemApi = {
    // æ‰§è¡Œæ–‡ä»¶
    async executeFile(filePath) {
        return await invokeCommand('execute_file', {filePath});
    },

    // åœ¨ç»ˆç«¯ä¸­æ‰“å¼€
    async openInTerminal(dirPath) {
        return await invokeCommand('open_in_terminal', {dirPath});
    },

    // åœ¨èµ„æºç®¡ç†å™¨ä¸­æ˜¾ç¤º
    async showInExplorer(filePath) {
        return await invokeCommand('show_in_explorer', {filePath});
    },

    // æ‰“å¼€URL
    async openUrl(url) {
        return await invokeCommand('open_url', {url});
    },

    // è·å–CLIå‚æ•°
    async getCliArgs() {
        return await invokeCommand('get_cli_args');
    }
};

// æ–‡ä»¶ç›‘æ§ API
export const watchApi = {
    // å¼€å§‹ç›‘æ§æ–‡ä»¶
    async startWatching(filePath) {
        return await invokeCommand('start_file_watching', {filePath});
    },

    // åœæ­¢ç›‘æ§æ–‡ä»¶
    async stopWatching(filePath) {
        return await invokeCommand('stop_file_watching', {filePath});
    },

    // æ£€æŸ¥æ–‡ä»¶å¤–éƒ¨å˜åŒ–
    async checkExternalChanges(filePath) {
        return await invokeCommand('check_file_external_changes', {filePath});
    }
};
```

### 2. äº‹ä»¶ç›‘å¬æœºåˆ¶

#### äº‹ä»¶ç›‘å¬å™¨è®¾ç½®

```javascript
import {listen} from '@tauri-apps/api/event';

// äº‹ä»¶ç›‘å¬å™¨ç®¡ç†
class EventManager {
    constructor() {
        this.listeners = new Map();
        this.setupEventListeners();
    }

    async setupEventListeners() {
        // æ–‡ä»¶å˜åŒ–äº‹ä»¶
        const fileChangeUnlisten = await listen('file-changed', (event) => {
            this.handleFileChange(event.payload);
        });
        this.listeners.set('file-changed', fileChangeUnlisten);

        // ç³»ç»Ÿä¸»é¢˜å˜åŒ–äº‹ä»¶
        const themeChangeUnlisten = await listen('theme-changed', (event) => {
            this.handleThemeChange(event.payload);
        });
        this.listeners.set('theme-changed', themeChangeUnlisten);

        // åº”ç”¨ç„¦ç‚¹äº‹ä»¶
        const focusUnlisten = await listen('app-focus', (event) => {
            this.handleAppFocus(event.payload);
        });
        this.listeners.set('app-focus', focusUnlisten);
    }

    handleFileChange(payload) {
        const {file_path, change_type, timestamp} = payload;

        console.log(`[Event] æ–‡ä»¶å˜åŒ–: ${file_path} (${change_type})`);

        // é€šçŸ¥ReduxçŠ¶æ€ç®¡ç†
        store.dispatch(fileChanged({
            filePath: file_path,
            changeType: change_type,
            timestamp
        }));

        // é€šçŸ¥ç›¸å…³ç»„ä»¶
        this.notifyComponents('file-changed', payload);
    }

    handleThemeChange(payload) {
        const {theme} = payload;

        console.log(`[Event] ç³»ç»Ÿä¸»é¢˜å˜åŒ–: ${theme}`);

        // å¦‚æœè®¾ç½®ä¸ºè·Ÿéšç³»ç»Ÿä¸»é¢˜
        const currentTheme = store.getState().theme;
        if (currentTheme.mode === 'auto') {
            store.dispatch(setSystemTheme(theme));
        }
    }

    handleAppFocus(payload) {
        const {focused} = payload;

        console.log(`[Event] åº”ç”¨ç„¦ç‚¹å˜åŒ–: ${focused}`);

        if (focused) {
            // åº”ç”¨è·å¾—ç„¦ç‚¹æ—¶ï¼Œæ£€æŸ¥æ–‡ä»¶å¤–éƒ¨å˜åŒ–
            this.checkAllFilesForExternalChanges();
        }
    }

    async checkAllFilesForExternalChanges() {
        const {openedFiles} = store.getState().file;

        for (const file of openedFiles) {
            try {
                const result = await watchApi.checkExternalChanges(file.path);

                if (result.success && result.data.changed) {
                    // æ–‡ä»¶æœ‰å¤–éƒ¨å˜åŒ–ï¼Œæç¤ºç”¨æˆ·
                    this.showExternalChangeDialog(file);
                }
            } catch (error) {
                console.error(`æ£€æŸ¥æ–‡ä»¶å¤–éƒ¨å˜åŒ–å¤±è´¥: ${file.path}`, error);
            }
        }
    }

    showExternalChangeDialog(file) {
        // æ˜¾ç¤ºæ–‡ä»¶å¤–éƒ¨å˜åŒ–å¯¹è¯æ¡†
        const dialog = {
            title: 'æ–‡ä»¶å¤–éƒ¨å˜åŒ–',
            message: `æ–‡ä»¶ "${file.name}" å·²è¢«å¤–éƒ¨ç¨‹åºä¿®æ”¹ï¼Œæ˜¯å¦é‡æ–°åŠ è½½ï¼Ÿ`,
            buttons: ['é‡æ–°åŠ è½½', 'ä¿ç•™å½“å‰ç‰ˆæœ¬', 'æ¯”è¾ƒå·®å¼‚'],
            defaultButton: 0
        };

        // è¿™é‡Œåº”è¯¥è°ƒç”¨å¯¹è¯æ¡†ç»„ä»¶
        showDialog(dialog).then((buttonIndex) => {
            switch (buttonIndex) {
                case 0: // é‡æ–°åŠ è½½
                    this.reloadFile(file);
                    break;
                case 1: // ä¿ç•™å½“å‰ç‰ˆæœ¬
                    // ä¸åšä»»ä½•æ“ä½œ
                    break;
                case 2: // æ¯”è¾ƒå·®å¼‚
                    this.showFileDiff(file);
                    break;
            }
        });
    }

    notifyComponents(eventType, payload) {
        // é€šè¿‡è‡ªå®šä¹‰äº‹ä»¶é€šçŸ¥ç»„ä»¶
        const customEvent = new CustomEvent(eventType, {
            detail: payload
        });

        window.dispatchEvent(customEvent);
    }

    // æ¸…ç†äº‹ä»¶ç›‘å¬å™¨
    cleanup() {
        this.listeners.forEach((unlisten) => {
            unlisten();
        });
        this.listeners.clear();
    }
}

// å…¨å±€äº‹ä»¶ç®¡ç†å™¨å®ä¾‹
export const eventManager = new EventManager();
```

---

## ğŸ”„ æ•°æ®æµç®¡ç†

### 1. Redux æ•°æ®æµ

#### æ•°æ®æµå‘å›¾

```
ç”¨æˆ·æ“ä½œ â†’ Action Creator â†’ Action â†’ Reducer â†’ Store â†’ Component
    â†‘                                                      â†“
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ UI æ›´æ–° â† Selector â† useSelector â†â”€â”€â”€â”€â”˜
```

#### å¼‚æ­¥æ•°æ®æµ

```javascript
// å¼‚æ­¥ Action Creator (ä½¿ç”¨ Redux Toolkit)
export const loadFileAsync = createAsyncThunk(
    'file/loadFile',
    async (filePath, {dispatch, getState, rejectWithValue}) => {
        try {
            // è®¾ç½®åŠ è½½çŠ¶æ€
            dispatch(setLoading(true));

            // è°ƒç”¨ Tauri API
            const result = await fileApi.readFile(filePath);

            if (!result.success) {
                return rejectWithValue(result.error);
            }

            // æ£€æµ‹è¯­è¨€ç±»å‹
            const language = detectLanguage(filePath);

            // æ·»åŠ åˆ°æœ€è¿‘æ–‡ä»¶
            dispatch(addToRecentFiles({
                path: filePath,
                name: getFileName(filePath),
                lastOpened: Date.now()
            }));

            return {
                ...result.data,
                language,
                filePath
            };

        } catch (error) {
            return rejectWithValue({
                code: 'LOAD_FILE_ERROR',
                message: error.message
            });
        } finally {
            dispatch(setLoading(false));
        }
    }
);

// åœ¨ç»„ä»¶ä¸­ä½¿ç”¨
function FileManager() {
    const dispatch = useDispatch();
    const {isLoading, error} = useSelector(state => state.file);

    const handleLoadFile = async (filePath) => {
        try {
            const result = await dispatch(loadFileAsync(filePath));

            if (loadFileAsync.fulfilled.match(result)) {
                // åŠ è½½æˆåŠŸ
                console.log('æ–‡ä»¶åŠ è½½æˆåŠŸ:', result.payload);
            } else {
                // åŠ è½½å¤±è´¥
                console.error('æ–‡ä»¶åŠ è½½å¤±è´¥:', result.payload);
            }
        } catch (error) {
            console.error('åŠ è½½æ–‡ä»¶æ—¶å‘ç”Ÿé”™è¯¯:', error);
        }
    };

    return (
        <div>
            {isLoading && <div>åŠ è½½ä¸­...</div>}
            {error && <div>é”™è¯¯: {error.message}</div>}
            <button onClick={() => handleLoadFile('/path/to/file.txt')}>
                åŠ è½½æ–‡ä»¶
            </button>
        </div>
    );
}
```

### 2. çŠ¶æ€åŒæ­¥æœºåˆ¶

#### çŠ¶æ€æŒä¹…åŒ–

```javascript
// çŠ¶æ€æŒä¹…åŒ–é…ç½®
const persistConfig = {
    key: 'root',
    storage: storage,
    whitelist: ['theme', 'editor', 'file'],
    transforms: [
        // ä¸»é¢˜çŠ¶æ€è½¬æ¢å™¨
        createTransform(
            // ä¿å­˜æ—¶è½¬æ¢
            (inboundState, key) => {
                if (key === 'theme') {
                    // ä¸ä¿å­˜èƒŒæ™¯å›¾ç‰‡ç­‰ä¸´æ—¶æ•°æ®
                    const {backgroundImage, ...rest} = inboundState;
                    return rest;
                }
                return inboundState;
            },
            // åŠ è½½æ—¶è½¬æ¢
            (outboundState, key) => {
                if (key === 'theme') {
                    return {
                        ...outboundState,
                        backgroundImage: null
                    };
                }
                return outboundState;
            }
        )
    ]
};

// çŠ¶æ€åŒæ­¥ä¸­é—´ä»¶
const stateSyncMiddleware = (store) => (next) => (action) => {
    const result = next(action);

    // åœ¨ç‰¹å®š action ååŒæ­¥çŠ¶æ€åˆ°åç«¯
    const syncActions = [
        'theme/setThemeMode',
        'editor/updateEditorConfig',
        'file/saveSession'
    ];

    if (syncActions.includes(action.type)) {
        // å¼‚æ­¥åŒæ­¥åˆ°åç«¯å­˜å‚¨
        syncStateToBackend(store.getState());
    }

    return result;
};

async function syncStateToBackend(state) {
    try {
        const syncData = {
            theme: state.theme,
            editor: state.editor,
            session: state.file.sessionData
        };

        await settingsApi.saveSettings('app-state', syncData);
    } catch (error) {
        console.error('åŒæ­¥çŠ¶æ€åˆ°åç«¯å¤±è´¥:', error);
    }
}
```

---

## ğŸ›¡ï¸ é”™è¯¯å¤„ç†æœºåˆ¶

### 1. é”™è¯¯åˆ†ç±»

| é”™è¯¯ç±»å‹ | é”™è¯¯ä»£ç                 | æè¿°     | å¤„ç†ç­–ç•¥  |
|------|---------------------|--------|-------|
| ç½‘ç»œé”™è¯¯ | `NETWORK_ERROR`     | ç½‘ç»œè¿æ¥é—®é¢˜ | é‡è¯•æœºåˆ¶  |
| æ–‡ä»¶é”™è¯¯ | `FILE_NOT_FOUND`    | æ–‡ä»¶ä¸å­˜åœ¨  | ç”¨æˆ·æç¤º  |
| æƒé™é”™è¯¯ | `PERMISSION_DENIED` | æƒé™ä¸è¶³   | æƒé™ç”³è¯·  |
| ç¼–ç é”™è¯¯ | `ENCODING_ERROR`    | æ–‡ä»¶ç¼–ç é—®é¢˜ | ç¼–ç è½¬æ¢  |
| ç³»ç»Ÿé”™è¯¯ | `SYSTEM_ERROR`      | ç³»ç»Ÿçº§é”™è¯¯  | é”™è¯¯æŠ¥å‘Š  |
| è¶…æ—¶é”™è¯¯ | `TIMEOUT_ERROR`     | æ“ä½œè¶…æ—¶   | é‡è¯•æˆ–å–æ¶ˆ |

### 2. é”™è¯¯å¤„ç†æµç¨‹

```javascript
// å…¨å±€é”™è¯¯å¤„ç†å™¨
class ErrorHandler {
    constructor() {
        this.errorQueue = [];
        this.isProcessing = false;
        this.setupGlobalHandlers();
    }

    setupGlobalHandlers() {
        // æ•è·æœªå¤„ç†çš„ Promise é”™è¯¯
        window.addEventListener('unhandledrejection', (event) => {
            this.handleError({
                type: 'UNHANDLED_PROMISE',
                error: event.reason,
                context: 'global'
            });
        });

        // æ•è· JavaScript é”™è¯¯
        window.addEventListener('error', (event) => {
            this.handleError({
                type: 'JAVASCRIPT_ERROR',
                error: event.error,
                context: 'global',
                filename: event.filename,
                lineno: event.lineno,
                colno: event.colno
            });
        });
    }

    async handleError(errorInfo) {
        const {type, error, context} = errorInfo;

        // é”™è¯¯åˆ†ç±»å¤„ç†
        switch (type) {
            case 'API_ERROR':
                await this.handleApiError(error, context);
                break;
            case 'FILE_ERROR':
                await this.handleFileError(error, context);
                break;
            case 'SYSTEM_ERROR':
                await this.handleSystemError(error, context);
                break;
            default:
                await this.handleGenericError(error, context);
        }
    }

    async handleApiError(error, context) {
        const {code, message} = error;

        switch (code) {
            case 'NETWORK_ERROR':
                // ç½‘ç»œé”™è¯¯ - æ˜¾ç¤ºé‡è¯•é€‰é¡¹
                this.showRetryDialog(message, () => {
                    // é‡è¯•é€»è¾‘
                    context.retry?.();
                });
                break;

            case 'TIMEOUT_ERROR':
                // è¶…æ—¶é”™è¯¯ - å¢åŠ è¶…æ—¶æ—¶é—´æˆ–å–æ¶ˆæ“ä½œ
                this.showTimeoutDialog(message, {
                    onRetry: context.retry,
                    onCancel: context.cancel
                });
                break;

            case 'PERMISSION_DENIED':
                // æƒé™é”™è¯¯ - ç”³è¯·æƒé™æˆ–æç¤ºç”¨æˆ·
                this.showPermissionDialog(message);
                break;

            default:
                this.showErrorNotification(message);
        }
    }

    async handleFileError(error, context) {
        const {code, message, details} = error;

        switch (code) {
            case 'FILE_NOT_FOUND':
                // æ–‡ä»¶ä¸å­˜åœ¨ - æç¤ºç”¨æˆ·é€‰æ‹©å…¶ä»–æ–‡ä»¶
                this.showFileNotFoundDialog(details.filePath);
                break;

            case 'ENCODING_ERROR':
                // ç¼–ç é”™è¯¯ - æä¾›ç¼–ç é€‰æ‹©
                this.showEncodingDialog(details.filePath, details.detectedEncodings);
                break;

            case 'FILE_LOCKED':
                // æ–‡ä»¶è¢«é”å®š - æç¤ºç¨åé‡è¯•
                this.showFileLockedDialog(details.filePath);
                break;

            default:
                this.showErrorNotification(message);
        }
    }

    showRetryDialog(message, onRetry) {
        const dialog = {
            type: 'error',
            title: 'ç½‘ç»œé”™è¯¯',
            message: message,
            buttons: ['é‡è¯•', 'å–æ¶ˆ'],
            defaultButton: 0
        };

        showDialog(dialog).then((buttonIndex) => {
            if (buttonIndex === 0) {
                onRetry();
            }
        });
    }

    showErrorNotification(message) {
        // æ˜¾ç¤ºé”™è¯¯é€šçŸ¥
        const notification = {
            type: 'error',
            title: 'æ“ä½œå¤±è´¥',
            message: message,
            duration: 5000
        };

        showNotification(notification);
    }

    // é”™è¯¯æŠ¥å‘Š
    async reportError(error, context) {
        const errorReport = {
            timestamp: Date.now(),
            error: {
                message: error.message,
                stack: error.stack,
                code: error.code
            },
            context: context,
            userAgent: navigator.userAgent,
            url: window.location.href,
            userId: getCurrentUserId() // å¦‚æœæœ‰ç”¨æˆ·ç³»ç»Ÿ
        };

        try {
            // å‘é€é”™è¯¯æŠ¥å‘Šåˆ°åç«¯
            await systemApi.reportError(errorReport);
        } catch (reportError) {
            console.error('å‘é€é”™è¯¯æŠ¥å‘Šå¤±è´¥:', reportError);
        }
    }
}

// å…¨å±€é”™è¯¯å¤„ç†å™¨å®ä¾‹
export const errorHandler = new ErrorHandler();
```

### 3. API è°ƒç”¨é”™è¯¯å¤„ç†

```javascript
// å¸¦é”™è¯¯å¤„ç†çš„ API è°ƒç”¨åŒ…è£…å™¨
export function withErrorHandling(apiCall, options = {}) {
    return async (...args) => {
        const {
            retries = 3,
            timeout = 10000,
            onError,
            onRetry,
            context
        } = options;

        let lastError;

        for (let attempt = 1; attempt <= retries; attempt++) {
            try {
                // è®¾ç½®è¶…æ—¶
                const timeoutPromise = new Promise((_, reject) => {
                    setTimeout(() => reject(new Error('TIMEOUT_ERROR')), timeout);
                });

                const apiPromise = apiCall(...args);
                const result = await Promise.race([apiPromise, timeoutPromise]);

                if (result.success) {
                    return result;
                }

                lastError = result.error;

                // åˆ¤æ–­æ˜¯å¦åº”è¯¥é‡è¯•
                if (shouldRetry(result.error) && attempt < retries) {
                    if (onRetry) {
                        onRetry(attempt, result.error);
                    }

                    // æŒ‡æ•°é€€é¿å»¶è¿Ÿ
                    const delay = Math.min(1000 * Math.pow(2, attempt - 1), 10000);
                    await new Promise(resolve => setTimeout(resolve, delay));
                    continue;
                }

                break;

            } catch (error) {
                lastError = {
                    code: error.message === 'TIMEOUT_ERROR' ? 'TIMEOUT_ERROR' : 'UNKNOWN_ERROR',
                    message: error.message,
                    details: error
                };

                if (attempt < retries) {
                    if (onRetry) {
                        onRetry(attempt, lastError);
                    }

                    const delay = Math.min(1000 * Math.pow(2, attempt - 1), 10000);
                    await new Promise(resolve => setTimeout(resolve, delay));
                }
            }
        }

        // æ‰€æœ‰é‡è¯•éƒ½å¤±è´¥äº†
        const finalError = {
            success: false,
            data: null,
            error: lastError
        };

        if (onError) {
            onError(finalError, context);
        } else {
            errorHandler.handleError({
                type: 'API_ERROR',
                error: lastError,
                context: context
            });
        }

        return finalError;
    };
}

// ä½¿ç”¨ç¤ºä¾‹
const safeReadFile = withErrorHandling(fileApi.readFile, {
    retries: 3,
    timeout: 5000,
    onError: (error, context) => {
        console.error('è¯»å–æ–‡ä»¶å¤±è´¥:', error);
        showErrorNotification(`æ— æ³•è¯»å–æ–‡ä»¶: ${context.filePath}`);
    },
    onRetry: (attempt, error) => {
        console.log(`é‡è¯•è¯»å–æ–‡ä»¶ (ç¬¬${attempt}æ¬¡):`, error);
    }
});

// åœ¨ç»„ä»¶ä¸­ä½¿ç”¨
async function handleOpenFile(filePath) {
    const result = await safeReadFile(filePath);

    if (result.success) {
        // å¤„ç†æˆåŠŸç»“æœ
        setFileContent(result.data.content);
    }
    // é”™è¯¯å·²ç»è¢« withErrorHandling å¤„ç†äº†
}
```

---

## ğŸš€ æ€§èƒ½ä¼˜åŒ–

### 1. API è°ƒç”¨ä¼˜åŒ–

#### è¯·æ±‚ç¼“å­˜æœºåˆ¶

```javascript
// API ç¼“å­˜ç®¡ç†å™¨
class ApiCache {
    constructor() {
        this.cache = new Map();
        this.cacheTimeout = 5 * 60 * 1000; // 5åˆ†é’Ÿç¼“å­˜
    }

    // ç”Ÿæˆç¼“å­˜é”®
    generateKey(command, payload) {
        return `${command}:${JSON.stringify(payload)}`;
    }

    // è·å–ç¼“å­˜
    get(command, payload) {
        const key = this.generateKey(command, payload);
        const cached = this.cache.get(key);

        if (cached && Date.now() - cached.timestamp < this.cacheTimeout) {
            return cached.data;
        }

        // ç¼“å­˜è¿‡æœŸï¼Œåˆ é™¤
        this.cache.delete(key);
        return null;
    }

    // è®¾ç½®ç¼“å­˜
    set(command, payload, data) {
        const key = this.generateKey(command, payload);
        this.cache.set(key, {
            data,
            timestamp: Date.now()
        });
    }

    // æ¸…é™¤ç¼“å­˜
    clear(pattern) {
        if (pattern) {
            for (const key of this.cache.keys()) {
                if (key.includes(pattern)) {
                    this.cache.delete(key);
                }
            }
        } else {
            this.cache.clear();
        }
    }
}

const apiCache = new ApiCache();

// å¸¦ç¼“å­˜çš„ API è°ƒç”¨
async function cachedInvoke(command, payload, useCache = true) {
    if (useCache) {
        const cached = apiCache.get(command, payload);
        if (cached) {
            console.log(`[Cache] å‘½ä¸­ç¼“å­˜: ${command}`);
            return cached;
        }
    }

    const result = await invokeCommand(command, payload);

    if (result.success && useCache) {
        apiCache.set(command, payload, result);
    }

    return result;
}
```

#### è¯·æ±‚æ‰¹å¤„ç†

```javascript
// æ‰¹å¤„ç†ç®¡ç†å™¨
class BatchProcessor {
    constructor() {
        this.batches = new Map();
        this.batchTimeout = 100; // 100ms æ‰¹å¤„ç†çª—å£
    }

    // æ·»åŠ åˆ°æ‰¹å¤„ç†é˜Ÿåˆ—
    add(command, payload) {
        return new Promise((resolve, reject) => {
            if (!this.batches.has(command)) {
                this.batches.set(command, {
                    requests: [],
                    timer: null
                });
            }

            const batch = this.batches.get(command);
            batch.requests.push({payload, resolve, reject});

            // è®¾ç½®æ‰¹å¤„ç†å®šæ—¶å™¨
            if (!batch.timer) {
                batch.timer = setTimeout(() => {
                    this.processBatch(command);
                }, this.batchTimeout);
            }
        });
    }

    // å¤„ç†æ‰¹å¤„ç†
    async processBatch(command) {
        const batch = this.batches.get(command);
        if (!batch || batch.requests.length === 0) {
            return;
        }

        const requests = batch.requests.splice(0);
        clearTimeout(batch.timer);
        batch.timer = null;

        try {
            // æ ¹æ®å‘½ä»¤ç±»å‹è¿›è¡Œæ‰¹å¤„ç†
            switch (command) {
                case 'get_file_info':
                    await this.batchGetFileInfo(requests);
                    break;
                case 'check_file_exists':
                    await this.batchCheckFileExists(requests);
                    break;
                default:
                    // ä¸æ”¯æŒæ‰¹å¤„ç†çš„å‘½ä»¤ï¼Œé€ä¸ªæ‰§è¡Œ
                    for (const request of requests) {
                        try {
                            const result = await invokeCommand(command, request.payload);
                            request.resolve(result);
                        } catch (error) {
                            request.reject(error);
                        }
                    }
            }
        } catch (error) {
            // æ‰¹å¤„ç†å¤±è´¥ï¼Œæ‹’ç»æ‰€æœ‰è¯·æ±‚
            requests.forEach(request => request.reject(error));
        }
    }

    async batchGetFileInfo(requests) {
        const filePaths = requests.map(req => req.payload.filePath);

        try {
            const result = await invokeCommand('batch_get_file_info', {filePaths});

            if (result.success) {
                // åˆ†å‘ç»“æœç»™å„ä¸ªè¯·æ±‚
                requests.forEach((request, index) => {
                    request.resolve({
                        success: true,
                        data: result.data[index]
                    });
                });
            } else {
                throw result.error;
            }
        } catch (error) {
            requests.forEach(request => request.reject(error));
        }
    }
}

const batchProcessor = new BatchProcessor();

// æ‰¹å¤„ç† API è°ƒç”¨
export function batchInvoke(command, payload) {
    return batchProcessor.add(command, payload);
}
```

### 2. æ•°æ®ä¼ è¾“ä¼˜åŒ–

#### æ•°æ®å‹ç¼©

```javascript
// æ•°æ®å‹ç¼©å·¥å…·
import {compress, decompress} from 'lz-string';

// å‹ç¼©å¤§æ–‡ä»¶å†…å®¹
function compressContent(content) {
    if (content.length > 10000) { // å¤§äº10KBçš„å†…å®¹è¿›è¡Œå‹ç¼©
        return {
            compressed: true,
            data: compress(content)
        };
    }

    return {
        compressed: false,
        data: content
    };
}

// è§£å‹ç¼©å†…å®¹
function decompressContent(data) {
    if (data.compressed) {
        return decompress(data.data);
    }

    return data.data;
}

// ä¼˜åŒ–çš„æ–‡ä»¶è¯»å–
export async function optimizedReadFile(filePath) {
    const result = await invokeCommand('read_file_content', {filePath});

    if (result.success) {
        // è§£å‹ç¼©å†…å®¹
        result.data.content = decompressContent(result.data.content);
    }

    return result;
}
```

#### æµå¼ä¼ è¾“

```javascript
// å¤§æ–‡ä»¶æµå¼è¯»å–
export async function streamReadFile(filePath, chunkSize = 64 * 1024) {
    const fileInfo = await fileApi.getFileInfo(filePath);

    if (!fileInfo.success) {
        return fileInfo;
    }

    const totalSize = fileInfo.data.size;
    const chunks = Math.ceil(totalSize / chunkSize);
    let content = '';

    for (let i = 0; i < chunks; i++) {
        const offset = i * chunkSize;
        const size = Math.min(chunkSize, totalSize - offset);

        const chunkResult = await invokeCommand('read_file_chunk', {
            filePath,
            offset,
            size
        });

        if (!chunkResult.success) {
            return chunkResult;
        }

        content += chunkResult.data.content;

        // é€šçŸ¥è¿›åº¦
        const progress = ((i + 1) / chunks) * 100;
        onProgress?.(progress);
    }

    return {
        success: true,
        data: {
            content,
            encoding: fileInfo.data.encoding,
            line_ending: fileInfo.data.line_ending
        }
    };
}
```

---

## ğŸ“Š ç›‘æ§å’Œè°ƒè¯•

### 1. API è°ƒç”¨ç›‘æ§

```javascript
// API ç›‘æ§å™¨
class ApiMonitor {
    constructor() {
        this.metrics = {
            totalCalls: 0,
            successCalls: 0,
            errorCalls: 0,
            averageResponseTime: 0,
            callsByCommand: new Map(),
            errorsByType: new Map()
        };

        this.isEnabled = process.env.NODE_ENV === 'development';
    }

    // è®°å½• API è°ƒç”¨
    recordCall(command, duration, success, error) {
        if (!this.isEnabled) return;

        this.metrics.totalCalls++;

        if (success) {
            this.metrics.successCalls++;
        } else {
            this.metrics.errorCalls++;

            if (error) {
                const errorType = error.code || 'UNKNOWN';
                this.metrics.errorsByType.set(
                    errorType,
                    (this.metrics.errorsByType.get(errorType) || 0) + 1
                );
            }
        }

        // æ›´æ–°å¹³å‡å“åº”æ—¶é—´
        this.metrics.averageResponseTime =
            (this.metrics.averageResponseTime * (this.metrics.totalCalls - 1) + duration) /
            this.metrics.totalCalls;

        // è®°å½•å‘½ä»¤è°ƒç”¨æ¬¡æ•°
        this.metrics.callsByCommand.set(
            command,
            (this.metrics.callsByCommand.get(command) || 0) + 1
        );
    }

    // è·å–ç›‘æ§æŠ¥å‘Š
    getReport() {
        return {
            ...this.metrics,
            successRate: (this.metrics.successCalls / this.metrics.totalCalls) * 100,
            errorRate: (this.metrics.errorCalls / this.metrics.totalCalls) * 100,
            callsByCommand: Object.fromEntries(this.metrics.callsByCommand),
            errorsByType: Object.fromEntries(this.metrics.errorsByType)
        };
    }

    // é‡ç½®ç›‘æ§æ•°æ®
    reset() {
        this.metrics = {
            totalCalls: 0,
            successCalls: 0,
            errorCalls: 0,
            averageResponseTime: 0,
            callsByCommand: new Map(),
            errorsByType: new Map()
        };
    }
}

const apiMonitor = new ApiMonitor();

// ç›‘æ§è£…é¥°å™¨
function withMonitoring(originalInvoke) {
    return async function (command, payload) {
        const startTime = performance.now();

        try {
            const result = await originalInvoke(command, payload);
            const duration = performance.now() - startTime;

            apiMonitor.recordCall(command, duration, result.success, result.error);

            return result;
        } catch (error) {
            const duration = performance.now() - startTime;
            apiMonitor.recordCall(command, duration, false, error);
            throw error;
        }
    };
}

// åº”ç”¨ç›‘æ§
const monitoredInvoke = withMonitoring(invokeCommand);
```

### 2. è°ƒè¯•å·¥å…·

```javascript
// API è°ƒè¯•å™¨
class ApiDebugger {
    constructor() {
        this.logs = [];
        this.maxLogs = 1000;
        this.isEnabled = process.env.NODE_ENV === 'development';
    }

    log(type, command, payload, result, duration) {
        if (!this.isEnabled) return;

        const logEntry = {
            timestamp: Date.now(),
            type,
            command,
            payload: JSON.parse(JSON.stringify(payload)), // æ·±æ‹·è´
            result: JSON.parse(JSON.stringify(result)),
            duration
        };

        this.logs.push(logEntry);

        // é™åˆ¶æ—¥å¿—æ•°é‡
        if (this.logs.length > this.maxLogs) {
            this.logs.shift();
        }

        // æ§åˆ¶å°è¾“å‡º
        const style = type === 'success' ? 'color: green' : 'color: red';
        console.groupCollapsed(`%c[API] ${command} (${duration}ms)`, style);
        console.log('Payload:', payload);
        console.log('Result:', result);
        console.groupEnd();
    }

    // è·å–è°ƒè¯•æ—¥å¿—
    getLogs(filter) {
        let logs = this.logs;

        if (filter) {
            logs = logs.filter(log => {
                if (filter.command && !log.command.includes(filter.command)) {
                    return false;
                }
                if (filter.type && log.type !== filter.type) {
                    return false;
                }
                if (filter.timeRange) {
                    const {start, end} = filter.timeRange;
                    if (log.timestamp < start || log.timestamp > end) {
                        return false;
                    }
                }
                return true;
            });
        }

        return logs;
    }

    // å¯¼å‡ºè°ƒè¯•æ—¥å¿—
    exportLogs() {
        const data = JSON.stringify(this.logs, null, 2);
        const blob = new Blob([data], {type: 'application/json'});
        const url = URL.createObjectURL(blob);

        const a = document.createElement('a');
        a.href = url;
        a.download = `api-debug-logs-${Date.now()}.json`;
        a.click();

        URL.revokeObjectURL(url);
    }

    // æ¸…é™¤æ—¥å¿—
    clearLogs() {
        this.logs = [];
    }
}

const apiDebugger = new ApiDebugger();

// è°ƒè¯•è£…é¥°å™¨
function withDebugging(originalInvoke) {
    return async function (command, payload) {
        const startTime = performance.now();

        try {
            const result = await originalInvoke(command, payload);
            const duration = performance.now() - startTime;

            apiDebugger.log('success', command, payload, result, duration);

            return result;
        } catch (error) {
            const duration = performance.now() - startTime;
            apiDebugger.log('error', command, payload, error, duration);
            throw error;
        }
    };
}

// å¼€å‘è€…å·¥å…·é›†æˆ
if (process.env.NODE_ENV === 'development') {
    window.__MIAOGU_DEBUG__ = {
        apiMonitor,
        apiDebugger,
        getApiReport: () => apiMonitor.getReport(),
        exportApiLogs: () => apiDebugger.exportLogs(),
        clearApiLogs: () => apiDebugger.clearLogs()
    };
}
```

---

## ğŸ”§ é…ç½®å’Œéƒ¨ç½²

### 1. ç¯å¢ƒé…ç½®

```javascript
// API é…ç½®
const apiConfig = {
    development: {
        timeout: 30000,
        retries: 3,
        cacheEnabled: true,
        debugEnabled: true,
        monitoringEnabled: true
    },

    production: {
        timeout: 10000,
        retries: 2,
        cacheEnabled: true,
        debugEnabled: false,
        monitoringEnabled: false
    },

    test: {
        timeout: 5000,
        retries: 1,
        cacheEnabled: false,
        debugEnabled: true,
        monitoringEnabled: true
    }
};

// è·å–å½“å‰ç¯å¢ƒé…ç½®
export function getApiConfig() {
    const env = process.env.NODE_ENV || 'development';
    return apiConfig[env] || apiConfig.development;
}
```

### 2. æ„å»ºä¼˜åŒ–

```javascript
// Vite é…ç½®ä¼˜åŒ–
export default defineConfig({
    // ... å…¶ä»–é…ç½®

    build: {
        rollupOptions: {
            output: {
                manualChunks: {
                    // å°† API ç›¸å…³ä»£ç åˆ†ç¦»åˆ°å•ç‹¬çš„ chunk
                    'api': ['./src/utils/tauriApi.js'],
                    'store': ['./src/store/index.js'],
                    'components': ['./src/components/index.js']
                }
            }
        }
    },

    // å¼€å‘æœåŠ¡å™¨é…ç½®
    server: {
        // ä»£ç†é…ç½®ï¼ˆå¦‚æœéœ€è¦ï¼‰
        proxy: {
            '/api': {
                target: 'http://localhost:3000',
                changeOrigin: true,
                rewrite: (path) => path.replace(/^\/api/, '')
            }
        }
    }
});
```

---

## ğŸ“ æœ€ä½³å®è·µ

### 1. API è®¾è®¡åŸåˆ™

1. **ä¸€è‡´æ€§**: æ‰€æœ‰ API ä½¿ç”¨ç»Ÿä¸€çš„è¯·æ±‚/å“åº”æ ¼å¼
2. **é”™è¯¯å¤„ç†**: æä¾›è¯¦ç»†çš„é”™è¯¯ä¿¡æ¯å’Œé”™è¯¯ä»£ç 
3. **æ€§èƒ½ä¼˜åŒ–**: ä½¿ç”¨ç¼“å­˜ã€æ‰¹å¤„ç†ã€å‹ç¼©ç­‰æŠ€æœ¯
4. **å®‰å…¨æ€§**: éªŒè¯è¾“å…¥å‚æ•°ï¼Œé˜²æ­¢æ³¨å…¥æ”»å‡»
5. **å¯æµ‹è¯•æ€§**: æä¾›æ¨¡æ‹Ÿæ•°æ®å’Œæµ‹è¯•å·¥å…·

### 2. å¼€å‘å»ºè®®

1. **ä½¿ç”¨ TypeScript**: æä¾›ç±»å‹å®‰å…¨å’Œæ›´å¥½çš„å¼€å‘ä½“éªŒ
2. **é”™è¯¯è¾¹ç•Œ**: åœ¨ç»„ä»¶å±‚é¢å¤„ç† API é”™è¯¯
3. **åŠ è½½çŠ¶æ€**: ä¸ºæ‰€æœ‰å¼‚æ­¥æ“ä½œæä¾›åŠ è½½æŒ‡ç¤º
4. **ç”¨æˆ·åé¦ˆ**: åŠæ—¶å‘ç”¨æˆ·åé¦ˆæ“ä½œç»“æœ
5. **æ—¥å¿—è®°å½•**: è®°å½•é‡è¦çš„ API è°ƒç”¨å’Œé”™è¯¯ä¿¡æ¯

### 3. æ€§èƒ½ä¼˜åŒ–å»ºè®®

1. **è¯·æ±‚åˆå¹¶**: åˆå¹¶ç›¸ä¼¼çš„ API è¯·æ±‚
2. **ç¼“å­˜ç­–ç•¥**: åˆç†ä½¿ç”¨ç¼“å­˜å‡å°‘é‡å¤è¯·æ±‚
3. **æ‡’åŠ è½½**: æŒ‰éœ€åŠ è½½æ•°æ®å’Œç»„ä»¶
4. **è™šæ‹ŸåŒ–**: å¯¹å¤§é‡æ•°æ®ä½¿ç”¨è™šæ‹Ÿæ»šåŠ¨
5. **é˜²æŠ–èŠ‚æµ**: å¯¹é¢‘ç¹çš„ç”¨æˆ·æ“ä½œè¿›è¡Œé˜²æŠ–å¤„ç†

---

## ğŸ” æ•…éšœæ’æŸ¥

### å¸¸è§é—®é¢˜å’Œè§£å†³æ–¹æ¡ˆ

| é—®é¢˜       | å¯èƒ½åŸå›          | è§£å†³æ–¹æ¡ˆ                |
|----------|--------------|---------------------|
| API è°ƒç”¨è¶…æ—¶ | ç½‘ç»œé—®é¢˜æˆ–åç«¯å“åº”æ…¢   | å¢åŠ è¶…æ—¶æ—¶é—´ï¼Œæ£€æŸ¥ç½‘ç»œè¿æ¥       |
| æ–‡ä»¶è¯»å–å¤±è´¥   | æ–‡ä»¶ä¸å­˜åœ¨æˆ–æƒé™ä¸è¶³   | æ£€æŸ¥æ–‡ä»¶è·¯å¾„å’Œæƒé™           |
| ç¼–ç é”™è¯¯     | æ–‡ä»¶ç¼–ç ä¸æ”¯æŒ      | æä¾›ç¼–ç é€‰æ‹©æˆ–è‡ªåŠ¨æ£€æµ‹         |
| å†…å­˜æ³„æ¼     | äº‹ä»¶ç›‘å¬å™¨æœªæ¸…ç†     | åœ¨ç»„ä»¶å¸è½½æ—¶æ¸…ç†ç›‘å¬å™¨         |
| çŠ¶æ€ä¸åŒæ­¥    | Redux çŠ¶æ€æ›´æ–°é—®é¢˜ | æ£€æŸ¥ reducer å’Œ action |

---

*æœ¬æ–‡æ¡£åŸºäº miaogu-notepad v1.4.0 ç‰ˆæœ¬ç¼–å†™ï¼Œæ¶µç›–äº†å®Œæ•´çš„ API äº¤äº’é€šè®¯æ¶æ„*
